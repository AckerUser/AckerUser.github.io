---
layout: post
title: 共识算法
date: 2022-05-14
tags: 共识算法
---

[TOC]



# 共识算法

### Paxos 算法

Paxos 算法是莱斯利·兰伯特(Leslie Lamport)1990 年提出的一种基于消息传递的、具有高 容错性的一致性算法。Google Chubby 的作者 Mike Burrows 说过，世上只有一种一致性算法， 那就是 Paxos，所有其他一致性算法都是 Paxos 算法的不完整版。Paxos 算法是一种公认的晦 涩难懂的算法，并且工程实现上也具有很大难度。较有名的 Paxos 工程实现有 Google Chubby、 ZAB、微信的 PhxPaxos 等。 

#### 三种角色

在 Paxos 算法中有三种角色，分别具有三种不同的行为。但很多时候，一个进程可能同 时充当着多种角色。 Proposal，提案 

- Proposer：提案者
- Acceptor：表决者
- Learner：学习者，同步者 

#### 一致性

 Paxos 算法的一致性主要体现在以下几点： 

- 每个提案者在提出提案时都会首先获取到一个递增的、全局唯一的提案编号 N，然后将该编号赋予其要提出的提案。 关于 N 的生成，有两种方式：全局性生成器、提案者自身维护 N。
- 每个表决者在 accept 某个提案后，会将该提案的编号 N 记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个编号最大的提案，其编号假设为 maxN。每个表决者仅会 accept 编号大于自己本地 maxN 的提案。 
- 在众多提案中最终只能有一个提案被选定。 
- 一旦一个提案被选定，则其它学习者会主动同步(Learn)该提案到本地。 
- 没有提案被提出则不会有提案被选定 

#### 提交算法

Paxos 对于提案的提交算法有两种方案，2PC 与 3PC。 

- 2PC：Two Phase Commit，即 prepare -> accept
- 3PC：Three Phase Commit，即 prepare -> accept -> commit 

<img width="100%" src="/images/2022051401.png" />

##### prepare 阶段 

1. 提案者(Proposer)准备提交一个编号为 N 的提议，于是其首先向所有表决者(Acceptor)发 送 prepare(N)请求，用于试探集群是否支持该编号的提议。
2. 每个表决者(Acceptor)中都保存着自己曾经 accept 过的提议中的最大编号 maxN。当一个 表决者接收到其它主机发送来的 prepare(N)请求时，其会比较 N 与 maxN 的值。有以下 几种情况： 
   1. 若 N 小于 maxN，则说明该提议已过时，当前表决者采取不回应或回应 Error 的方 式来拒绝该 prepare 请求； 
   2. 若 N 大于 maxN，则说明该提议是可以接受的，当前表决者会首先将该 N 记录下来， 并将其曾经已经 accept 的编号最大的提案 Proposal(myid,maxN,value)反馈给提案者， 以向提案者展示自己支持的提案意愿。其中第一个参数 myid 表示该提案的提案者 标识 id，第二个参数表示其曾接受的提案的最大编号 maxN，第三个参数表示该提 案的真正内容 value。当然，若当前表决者还未曾 accept 过任何提议，则会将 Proposal(null,null,null)反馈给提案者。 
   3. 在 prepare 阶段 N 不可能等于 maxN。这是由 N 的生成机制决定的。要获得 N 的值， 其必定会在原来数值的基础上采用同步锁方式增一。 

##### accept 阶段 

1. 当提案者(Proposer)发出 prepare(N)后，若收到了超过半数的表决者(Accepter)的反馈， 那么该提案者就会将其真正的提案 Proposal(myid,N,value)发送给所有的表决者。 
2. 当表决者(Acceptor)接收到提案者发送的 Proposal(myid,N,value)提案后，会再次拿出自己曾经 accept 过的提议中的最大编号 maxN，或曾经记录下的 prepare 的最大编号，让 N 与它们进行比较，若 N 大于等于这两个编号，则当前表决者 accept 该提案，并反馈给 提案者。若 N 小于这两个编号，则表决者采取不回应或回应 Error 的方式来拒绝该提议。 
3. 若提案者没有接收到超过半数的表决者的 accept 反馈，则有两种可能的结果产生。一 是放弃该提案，不再提出；二是重新进入 prepare 阶段，递增提案号，重新提出 prepare 请求。

##### commit 阶段 

若提案者接收到的反馈数量超过了半数，则其会向外广播两类信息： 

1. 向曾 accept 其提案的表决者发送“可执行数据同步信号”，即让它们执行其曾接收 到的提案； 
2. 向未曾向其发送 accept 反馈的表决者发送“提案 + 可执行数据同步信号”，即让 它们接受到该提案后马上执行 

### CAP 定理 

 CAP 定理又称 CAP 原则，指的是在一个分布式系统中，Consistency（一致性）、Availability （可用性）、Partition tolerance（分区容错性），三者不可兼得 

-  一致性（C）：分布式系统中多个主机之间是否能够保持数据一致的特性。即，当系统数 据发生更新操作后，各个主机中的数据仍然处于一致的状态  
-  可用性（A）：系统提供的服务是否一直处于可用的状态，即对于用户的每一个请求，系 统是否总是可以在有限的时间内对用户做出响应 
-  分区容错性（P）：分布式系统在遇到任何网络分区故障时，仍能够保证对外提供满足一 致性和可用性的服务。 分区是网络分区 

 对于分布式系统，网络环境相对是不可控的，出现网络分区是不可避免的，因此系统必 须具备分区容错性。但其并不能同时保证一致性与可用性。CAP 原则对于一个分布式系统来 说，只可能满足两项，即要么 CP，要么 AP 

### BASE理论

BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最 终一致性）三个短语的简写。 

BASE 理论的核心思想是：即使无法做到实时一致性，但每个系统都可以根据自身的业 务特点，采用适当的方式来使系统达到最终一致性 

- 基本可用（BA） 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性 
- 软状态（S） 软状态，是指允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的 整体可用性，即允许系统主机间进行数据同步的过程存在一定延时。软状态，其实就是一种 灰度状态，过渡状态 
- 最终一致性（E） 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到 一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需 要实时保证系统数据的一致性 

 从达到一致性的时间角度来划分，可以分为： 

- 实时一致性：单机情况下可以实现实时一致性 
- 最终一致性：经过一段时间后可以达到一致性

单从客户端访问到的内容角度来划分，可以分为： 

- 强一致性（严格一致性）：要求客户端访问到的数据都是一致
- 弱一致性：允许客户端访问不到部分或全部更新过的数据 